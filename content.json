{"meta":{"title":"一个青年的Class","subtitle":"Stay Hungry, Stay Foolish","description":"个人战，主要涉及知识共享,实践教程,前沿技术共同学习等方面","author":"杨瑞峰","url":"RmBBBBBBBBB.github.io.git"},"pages":[{"title":"about","date":"2018-11-21T03:22:53.000Z","updated":"2018-11-21T03:22:53.780Z","comments":true,"path":"about/index.html","permalink":"RmBBBBBBBBB.github.io.git/about/index.html","excerpt":"","text":""},{"title":"","date":"2018-11-21T03:22:47.000Z","updated":"2019-02-18T02:26:11.362Z","comments":false,"path":"categories/index.html","permalink":"RmBBBBBBBBB.github.io.git/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2018-11-21T03:22:31.000Z","updated":"2018-11-21T03:28:33.702Z","comments":false,"path":"tags/index.html","permalink":"RmBBBBBBBBB.github.io.git/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"SpringSecurity入门Demo","slug":"springSecurity","date":"2019-02-28T05:33:26.792Z","updated":"2019-02-28T05:33:26.790Z","comments":true,"path":"springSecurity/","link":"","permalink":"RmBBBBBBBBB.github.io.git/springSecurity/","excerpt":"","text":"一:往maven的 pom 文件中添加 jar 包123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051&lt;properties&gt; &lt;spring.version&gt;4.2.4.RELEASE&lt;/spring.version&gt;&lt;/properties&gt;&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-core&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-web&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context-support&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-test&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.security&lt;/groupId&gt; &lt;artifactId&gt;spring-security-web&lt;/artifactId&gt; &lt;version&gt;4.1.0.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.security&lt;/groupId&gt; &lt;artifactId&gt;spring-security-config&lt;/artifactId&gt; &lt;version&gt;4.1.0.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;servlet-api&lt;/artifactId&gt; &lt;version&gt;2.5&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 二:给Web.xml中添加配置信息12345678910111213141516171819202122232425&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;web-app xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns=&quot;http://java.sun.com/xml/ns/javaee&quot; xsi:schemaLocation=&quot;http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd&quot; version=&quot;2.5&quot;&gt; &lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:spring-security.xml&lt;/param-value&gt; &lt;/context-param&gt; &lt;listener&gt; &lt;listener-class&gt; org.springframework.web.context.ContextLoaderListener &lt;/listener-class&gt; &lt;/listener&gt; &lt;filter&gt; &lt;filter-name&gt;springSecurityFilterChain&lt;/filter-name&gt; &lt;filter-class&gt; org.springframework.web.filter.DelegatingFilterProxy &lt;/filter-class&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;springSecurityFilterChain&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; &lt;/web-app&gt; 三:创建 index.html 页面四:创建 Spring配置文件 Spring-secutiry.xml123456789101112131415161718192021222324252627282930&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans:beans xmlns=&quot;http://www.springframework.org/schema/security&quot; xmlns:beans=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/security http://www.springframework.org/schema/security/spring-security.xsd&quot;&gt; &lt;!-- intercept-url 表示拦截页面 /* 表示的是该目录下的资源，只包括本级目录不包括下级目录 /** 表示的是该目录以及该目录下所有级别子目录的资源 form-login 为开启表单登陆 use-expressions 为是否使用使用 Spring 表达式语言（ SpEL ），默认为true ,如果开启，则拦截的配置应该写成以下形式 &lt;intercept-url pattern=&quot;/**&quot; access=&quot;hasRole(&apos;ROLE_USER&apos;)&quot; /&gt; --&gt; &lt;!-- 页面拦截规则 --&gt; &lt;http use-expressions=&quot;false&quot;&gt; &lt;intercept-url pattern=&quot;/**&quot; access=&quot;ROLE_USER&quot; /&gt; &lt;form-login/&gt; &lt;/http&gt; &lt;!-- 认证管理器 --&gt; &lt;authentication-manager&gt; &lt;authentication-provider&gt; &lt;user-service&gt; &lt;user name=&quot;admin&quot; password=&quot;123456&quot; authorities=&quot;ROLE_USER&quot;/&gt; &lt;/user-service&gt; &lt;/authentication-provider&gt; &lt;/authentication-manager&gt;&lt;/beans:beans&gt; 五:自定一登陆页面12345678910111213141516171819202122232425&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot;&gt;&lt;title&gt;登陆&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;form action=&apos;/login&apos; method=&apos;POST&apos;&gt; &lt;table&gt; &lt;tr&gt; &lt;td&gt;用户名:&lt;/td&gt; &lt;td&gt;&lt;input type=&apos;text&apos; name=&apos;username&apos; value=&apos;&apos;&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;密码:&lt;/td&gt; &lt;td&gt;&lt;input type=&apos;password&apos; name=&apos;password&apos; /&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td colspan=&apos;2&apos;&gt;&lt;input name=&quot;submit&quot; type=&quot;submit&quot; value=&quot;登陆&quot; /&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 六:配置自定义的登录页1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans:beans xmlns=&quot;http://www.springframework.org/schema/security&quot; xmlns:beans=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/security http://www.springframework.org/schema/security/spring-security.xsd&quot;&gt; &lt;!-- intercept-url 表示拦截页面 /* 表示的是该目录下的资源，只包括本级目录不包括下级目录 /** 表示的是该目录以及该目录下所有级别子目录的资源 form-login 为开启表单登陆 use-expressions 为是否使用使用 Spring 表达式语言（ SpEL ），默认为true ,如果开启，则拦截的配置应该写成以下形式 &lt;intercept-url pattern=&quot;/**&quot; access=&quot;hasRole(&apos;ROLE_USER&apos;)&quot; /&gt; --&gt; &lt;!-- 以下页面不被拦截 security=&quot;none&quot; 设置此资源不被拦截. --&gt; &lt;http pattern=&quot;/login.html&quot; security=&quot;none&quot;&gt;&lt;/http&gt; &lt;http pattern=&quot;/login_error.html&quot; security=&quot;none&quot;&gt;&lt;/http&gt; &lt;!--如果没有设置 security=&quot;none&quot; 报错：该页面无发正常操作，重定向次数过多 因为登录页会被反复重定向。 --&gt; &lt;!-- 页面拦截规则 login-page：指定登录页面。 authentication-failure-url：指定了身份验证失败时跳转到的页面。 default-target-url：指定了成功进行身份验证和授权后默认呈现给用户的页面。 --&gt; &lt;http use-expressions=&quot;false&quot;&gt; &lt;intercept-url pattern=&quot;/**&quot; access=&quot;ROLE_USER&quot; /&gt; &lt;form-login login-page=&quot;/login.html&quot; default-target-url=&quot;/index.html&quot; authentication-failure-url=&quot;/login_error.html&quot;/&gt; &lt;csrf disabled=&quot;true&quot;/&gt; &lt;!-- csrf disabled=&quot;true&quot; 关闭csrf ,如果不加会出现错误 : HTTP Status 403 CSRF（Cross-site request forgery）跨站请求伪造，也被称为“One Click Attack”或者Session Riding，通常缩写为CSRF或者XSRF，是一种对网站的恶意利用。 --&gt; &lt;/http&gt; &lt;!-- 认证管理器 --&gt; &lt;authentication-manager&gt; &lt;authentication-provider&gt; &lt;user-service&gt; &lt;user name=&quot;admin&quot; password=&quot;123456&quot; authorities=&quot;ROLE_USER&quot;/&gt; &lt;/user-service&gt; &lt;/authentication-provider&gt; &lt;/authentication-manager&gt;&lt;/beans:beans&gt;","categories":[{"name":"技术","slug":"技术","permalink":"RmBBBBBBBBB.github.io.git/categories/技术/"}],"tags":[{"name":"SpringSecurity","slug":"SpringSecurity","permalink":"RmBBBBBBBBB.github.io.git/tags/SpringSecurity/"}]},{"title":"Http单向，双向认证","slug":"http单向双向认证","date":"2019-02-18T02:22:39.719Z","updated":"2019-02-18T02:22:39.719Z","comments":true,"path":"http单向双向认证/","link":"","permalink":"RmBBBBBBBBB.github.io.git/http单向双向认证/","excerpt":"","text":"一、HttpHyperText Transfer Protocol，超文本传输协议，是互联网上使用最广泛的一种协议，所有WWW文件必须遵循的标准。HTTP协议传输的数据都是未加密的，也就是明文的，因此使用HTTP协议传输隐私信息非常不安全。 使用TCP端口为：80 二、HttpsHyper Text Transfer Protocol over Secure Socket Layer，安全的超文本传输协议，网景公式设计了SSL(Secure Sockets Layer)协议用于对Http协议传输的数据进行加密，保证会话过程中的安全性。 使用TCP端口默认为443 三、SSL协议加密方式SSL协议即用到了对称加密也用到了非对称加密(公钥加密)，在建立传输链路时，SSL首先对对称加密的密钥使用公钥进行非对称加密，链路建立好之后，SSL对传输内容使用对称加密。 对称加密速度高，可加密内容较大，用来加密会话过程中的消息 公钥加密加密速度较慢，但能提供更好的身份认证技术，用来加密对称加密的密钥 四、单向认证Https在建立Socket连接之前，需要进行握手，具体过程如下： 1、客户端向服务端发送SSL协议版本号、加密算法种类、随机数等信息。 2、服务端给客户端返回SSL协议版本号、加密算法种类、随机数等信息，同时也返回服务器端的证书，即公钥证书 3、客户端使用服务端返回的信息验证服务器的合法性，包括： 证书是否过期 发型服务器证书的CA是否可靠 返回的公钥是否能正确解开返回证书中的数字签名 服务器证书上的域名是否和服务器的实际域名相匹配 验证通过后，将继续进行通信，否则，终止通信 4、客户端向服务端发送自己所能支持的对称加密方案，供服务器端进行选择 5、服务器端在客户端提供的加密方案中选择加密程度最高的加密方式。 6、服务器将选择好的加密方案通过明文方式返回给客户端 7、客户端接收到服务端返回的加密方式后，使用该加密方式生成产生随机码，用作通信过程中对称加密的密钥，使用服务端返回的公钥进行加密，将加密后的随机码发送至服务器 8、服务器收到客户端返回的加密信息后，使用自己的私钥进行解密，获取对称加密密钥。 在接下来的会话中，服务器和客户端将会使用该密码进行对称加密，保证通信过程中信息的安全。 五、双向认证双向认证和单向认证原理基本差不多，只是除了客户端需要认证服务端以外，增加了服务端对客户端的认证，具体过程如下： 1、客户端向服务端发送SSL协议版本号、加密算法种类、随机数等信息。 2、服务端给客户端返回SSL协议版本号、加密算法种类、随机数等信息，同时也返回服务器端的证书，即公钥证书 3、客户端使用服务端返回的信息验证服务器的合法性，包括： 证书是否过期 发型服务器证书的CA是否可靠 返回的公钥是否能正确解开返回证书中的数字签名 服务器证书上的域名是否和服务器的实际域名相匹配 验证通过后，将继续进行通信，否则，终止通信 4、服务端要求客户端发送客户端的证书，客户端会将自己的证书发送至服务端 5、验证客户端的证书，通过验证后，会获得客户端的公钥 6、客户端向服务端发送自己所能支持的对称加密方案，供服务器端进行选择 7、服务器端在客户端提供的加密方案中选择加密程度最高的加密方式 8、将加密方案通过使用之前获取到的公钥进行加密，返回给客户端 9、客户端收到服务端返回的加密方案密文后，使用自己的私钥进行解密，获取具体加密方式，而后，产生该加密方式的随机码，用作加密过程中的密钥，使用之前从服务端证书中获取到的公钥进行加密后，发送给服务端 10、服务端收到客户端发送的消息后，使用自己的私钥进行解密，获取对称加密的密钥，在接下来的会话中，服务器和客户端将会使用该密码进行对称加密，保证通信过程中信息的安全。","categories":[{"name":"技术","slug":"技术","permalink":"RmBBBBBBBBB.github.io.git/categories/技术/"}],"tags":[{"name":"ssL","slug":"ssL","permalink":"RmBBBBBBBBB.github.io.git/tags/ssL/"}]},{"title":"HttpClient验证接口","slug":"HttpClient验证接口","date":"2019-02-15T08:24:27.937Z","updated":"2019-02-15T08:24:27.925Z","comments":true,"path":"HttpClient验证接口/","link":"","permalink":"RmBBBBBBBBB.github.io.git/HttpClient验证接口/","excerpt":"","text":"Http协议的重要性相信不用我多说了，HttpClient相比传统JDK自带的URLConnection，增加了易用性和灵活性（具体区别，日后我们再讨论），它不仅是客户端发送Http请求变得容易，而且也方便了开发人员测试接口（基于Http协议的），即提高了开发的效率，也方便提高代码的健壮性。因此熟练掌握HttpClient是很重要的必修内容，掌握HttpClient后，相信对于Http协议的了解会更加深入。 一、简介HttpClient是Apache Jakarta Common下的子项目，用来提供高效的、最新的、功能丰富的支持HTTP协议的客户端编程工具包，并且它支持HTTP协议最新的版本和建议。HttpClient已经应用在很多的项目中，比如Apache Jakarta上很著名的另外两个开源项目Cactus和HTMLUnit都使用了HttpClient。 下载地址: http://hc.apache.org/downloads.cgi 二、特性 基于标准、纯净的java语言。实现了Http1.0和Http1.1 以可扩展的面向对象的结构实现了Http全部的方法（GET, POST, PUT, DELETE, HEAD, OPTIONS, and TRACE）。 支持HTTPS协议。 通过Http代理建立透明的连接。 利用CONNECT方法通过Http代理建立隧道的https连接。 Basic, Digest, NTLMv1, NTLMv2, NTLM2 Session, SNPNEGO/Kerberos认证方案。 插件式的自定义认证方案。 便携可靠的套接字工厂使它更容易的使用第三方解决方案。 连接管理器支持多线程应用。支持设置最大连接数，同时支持设置每个主机的最大连接数，发现并关闭过期的连接。 自动处理Set-Cookie中的Cookie。 插件式的自定义Cookie策略。 Request的输出流可以避免流中内容直接缓冲到socket服务器。 Response的输入流可以有效的从socket服务器直接读取相应内容。 在http1.0和http1.1中利用KeepAlive保持持久连接。 直接获取服务器发送的response code和 headers。 设置连接超时的能力。 实验性的支持http1.1 response caching。 源代码基于Apache License 可免费获取。 三、使用方法使用HttpClient发送请求、接收响应很简单，一般需要如下几步即可。 创建HttpClient对象。 创建请求方法的实例，并指定请求URL。如果需要发送GET请求，创建HttpGet对象；如果需要发送POST请求，创建HttpPost对象。 如果需要发送请求参数，可调用HttpGet、HttpPost共同的setParams(HetpParams params)方法来添加请求参数；对于HttpPost对象而言，也可调用setEntity(HttpEntity entity)方法来设置请求参数。 调用HttpClient对象的execute(HttpUriRequest request)发送请求，该方法返回一个HttpResponse。 调用HttpResponse的getAllHeaders()、getHeaders(String name)等方法可获取服务器的响应头；调用HttpResponse的getEntity()方法可获取HttpEntity对象，该对象包装了服务器的响应内容。程序可通过该对象获取服务器的响应内容。 释放连接。无论执行方法是否成功，都必须释放连接 第一种验证方式： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155import java.io.File;import java.io.FileInputStream;import java.io.IOException;import java.net.Socket;import java.net.UnknownHostException;import java.security.KeyManagementException;import java.security.KeyStoreException;import java.security.UnrecoverableKeyException;import java.security.KeyStore;import java.security.NoSuchAlgorithmException;import java.security.cert.CertificateException;import java.security.cert.X509Certificate;import javax.net.ssl.KeyManager;import javax.net.ssl.KeyManagerFactory;import javax.net.ssl.SSLContext;import javax.net.ssl.X509TrustManager;import javax.net.ssl.TrustManager;import org.apache.http.HttpEntity;import org.apache.http.HttpResponse;import org.apache.http.HttpVersion;import org.apache.http.client.HttpClient;import org.apache.http.client.methods.HttpPost;import org.apache.http.conn.ClientConnectionManager;import org.apache.http.conn.scheme.PlainSocketFactory;import org.apache.http.conn.scheme.Scheme;import org.apache.http.conn.scheme.SchemeRegistry;import org.apache.http.conn.socket.ConnectionSocketFactory;import org.apache.http.conn.socket.PlainConnectionSocketFactory;import org.apache.http.conn.ssl.SSLConnectionSocketFactory;import org.apache.http.conn.ssl.SSLSocketFactory;import org.apache.http.conn.ssl.TrustStrategy;import org.apache.http.conn.ssl.TrustSelfSignedStrategy;import org.apache.http.entity.StringEntity;import org.apache.http.impl.client.CloseableHttpClient;import org.apache.http.impl.client.DefaultHttpClient;import org.apache.http.impl.client.HttpClients;import org.apache.http.impl.conn.BasicClientConnectionManager;import org.apache.http.impl.conn.DefaultProxyRoutePlanner;import org.apache.http.impl.conn.PoolingHttpClientConnectionManager;import org.apache.http.message.BasicNameValuePair;import org.apache.http.params.BasicHttpParams;import org.apache.http.params.HttpParams;import org.apache.http.params.HttpProtocolParams;import org.apache.http.protocol.HTTP;import org.apache.http.util.EntityUtils;/**- @param keyStorePath 密钥库路径 @param keyStorepass 密钥库密码 - @return / public static HttpClient customSSLClient(String keyStorePath, String keyStorepass) throws Exception &#123; HttpClient httpClient; // KeyStore trustStore = KeyStore.getInstance(\"PKCS12\"); // KeyStore trustStore = KeyStore.getInstance(KeyStore.getDefaultType()); KeyStore trustStore = KeyStore.getInstance(\"JKS\"); FileInputStream instream = new FileInputStream(new File(keyStorePath)); try &#123; trustStore.load(instream, keyStorepass.toCharArray()); &#125; finally &#123; try &#123; instream.close(); &#125; catch (Exception ignore) &#123; &#125; &#125; SSLSocketFactory sf = new SSLSocketFactoryEx(trustStore, keyStorepass.toCharArray()); sf.setHostnameVerifier(SSLSocketFactory.ALLOW_ALL_HOSTNAME_VERIFIER); HttpParams params = new BasicHttpParams(); HttpProtocolParams.setVersion(params, HttpVersion.HTTP_1_1); HttpProtocolParams.setContentCharset(params, HTTP.UTF_8); SchemeRegistry registry = new SchemeRegistry(); registry.register(new Scheme(\"http\", PlainSocketFactory.getSocketFactory(), 80)); registry.register(new Scheme(\"https\", sf, 443)); ClientConnectionManager ccm = new BasicClientConnectionManager(registry); httpClient = new DefaultHttpClient(ccm); return httpClient; &#125; private static class SSLSocketFactoryEx extends SSLSocketFactory &#123; SSLContext sslContext = SSLContext.getInstance(\"TLS\"); public SSLSocketFactoryEx(KeyStore truststore, char[] arry) throws NoSuchAlgorithmException, KeyManagementException, KeyStoreException, UnrecoverableKeyException &#123; super(truststore); KeyManagerFactory localKeyManagerFactory = KeyManagerFactory.getInstance(KeyManagerFactory .getDefaultAlgorithm()); localKeyManagerFactory.init(truststore, arry); KeyManager[] arrayOfKeyManager = localKeyManagerFactory.getKeyManagers(); TrustManager tm = new X509TrustManager() &#123; @Override public X509Certificate[] getAcceptedIssuers() &#123; return null; &#125; @Override public void checkServerTrusted(X509Certificate[] chain, String authType) throws CertificateException &#123; &#125; @Override public void checkClientTrusted(X509Certificate[] chain, String authType) throws CertificateException &#123; &#125; &#125;; sslContext.init(arrayOfKeyManager, new TrustManager[]&#123;tm&#125;, new java.security.SecureRandom()); &#125; @Override public Socket createSocket(Socket socket, String host, int port, boolean autoClose) throws IOException, UnknownHostException &#123; return sslContext.getSocketFactory().createSocket(socket, host, port, autoClose); &#125; @Override public Socket createSocket() throws IOException &#123; return sslContext.getSocketFactory().createSocket(); &#125; &#125; //main方法public static void main(String[] args) throws Exception &#123; String keyStorePath =\"d:\\\\java\\\\hgclient.keystore\"; String keyStorepass =\"123456\"; HttpClient customSSLClient = customSSLClient(keyStorePath, keyStorepass); HttpPost httpPost = new HttpPost(\"https://114.116.131.5:18443/hgpayment/XmlTransServlet\"); HttpResponse execute = customSSLClient.execute(httpPost); if(execute.getStatusLine().getStatusCode()==200)&#123; HttpEntity entity = execute.getEntity();//调用getEntity()方法获取到一个HttpEntity实例 //用EntityUtils.toString()这个静态方法将HttpEntity转换成字符串,防止服务器返回的数据带有中文,所以在转换的时候将字符集指定成utf-8就可以了 String string = EntityUtils.toString(entity,\"utf-8\"); System.out.println(\"--EntityUtils--\"+string); System.out.println(\"response.getStatusLine()-----\"+execute.getStatusLine()); &#125; &#125; 第二种验证方式：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667import org.apache.commons.io.IOUtils;import org.apache.http.HttpEntity;import org.apache.http.client.methods.CloseableHttpResponse;import org.apache.http.client.methods.HttpPost;import org.apache.http.conn.ssl.SSLConnectionSocketFactory;import org.apache.http.conn.ssl.TrustStrategy;import org.apache.http.impl.client.CloseableHttpClient;import org.apache.http.impl.client.HttpClients;import org.apache.http.ssl.SSLContexts;import org.apache.http.util.EntityUtils;import javax.net.ssl.SSLContext;import java.io.File;import java.io.FileInputStream;import java.security.KeyStore;import java.security.cert.CertificateException;import java.security.cert.X509Certificate;public static void main(String[] args) throws Exception &#123; KeyStore keyStore = KeyStore.getInstance(\"PKCS12\"); keyStore.load(new FileInputStream(new File(\"D:\\\\java\\\\hgclient.keystore\")), \"123456\".toCharArray()); SSLContext sslcontext = SSLContexts.custom() //忽略掉对服务器端证书的校验 .loadTrustMaterial(new TrustStrategy() &#123; @Override public boolean isTrusted(X509Certificate[] chain, String authType) throws CertificateException &#123; return true; &#125; &#125;) //加载服务端提供的truststore(如果服务器提供truststore的话就不用忽略对服务器端证书的校验了) //.loadTrustMaterial(new File(\"D:\\\\truststore.jks\"), \"123456\".toCharArray(), // new TrustSelfSignedStrategy()) .loadKeyMaterial(keyStore, \"123456\".toCharArray()) .build(); SSLConnectionSocketFactory sslConnectionSocketFactory = new SSLConnectionSocketFactory( sslcontext, new String[]&#123;\"TLSv1\"&#125;, null, SSLConnectionSocketFactory.getDefaultHostnameVerifier()); CloseableHttpClient httpclient = HttpClients.custom() .setSSLSocketFactory(sslConnectionSocketFactory) .build(); try &#123; // HttpGet httpget = new HttpGet(\"https://114.116.131.5:18443/hgpayment/XmlTransServlet\"); // HttpPost HttpPost = new HttpPost(\"https://114.116.131.5:18443/hgpayment/XmlTransServlet\"); HttpPost HttpPost = new HttpPost(\"https://114.116.131.5:18443/hgsptsmsm/XmlSptsmServlet\"); // HttpPost HttpPost = new HttpPost(\"https://sptsm.heigo.com.cn/hgpayment/XmlTransServlet\"); System.out.println(\"Executing request \" + HttpPost.getRequestLine()); CloseableHttpResponse response = httpclient.execute(HttpPost); try &#123; HttpEntity entity = response.getEntity(); System.out.println(\"response.getStatusLine()-----\"+response.getStatusLine()); System.out.println(\"----IO----\"+IOUtils.toString(entity.getContent())); EntityUtils.consume(entity); &#125; finally &#123; response.close(); &#125; &#125; finally &#123; httpclient.close(); &#125; &#125; 第三种验证post，get，upload123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275import java.io.File;import java.io.FileInputStream;import java.io.IOException;import java.io.UnsupportedEncodingException;import java.security.KeyManagementException;import java.security.KeyStore;import java.security.KeyStoreException;import java.security.NoSuchAlgorithmException;import java.security.cert.CertificateException;import java.util.ArrayList;import java.util.List; import javax.net.ssl.SSLContext; import org.apache.http.HttpEntity;import org.apache.http.NameValuePair;import org.apache.http.ParseException;import org.apache.http.client.ClientProtocolException;import org.apache.http.client.entity.UrlEncodedFormEntity;import org.apache.http.client.methods.CloseableHttpResponse;import org.apache.http.client.methods.HttpGet;import org.apache.http.client.methods.HttpPost;import org.apache.http.conn.ssl.SSLConnectionSocketFactory;import org.apache.http.conn.ssl.SSLContexts;import org.apache.http.conn.ssl.TrustSelfSignedStrategy;import org.apache.http.entity.ContentType;import org.apache.http.entity.mime.MultipartEntityBuilder;import org.apache.http.entity.mime.content.FileBody;import org.apache.http.entity.mime.content.StringBody;import org.apache.http.impl.client.CloseableHttpClient;import org.apache.http.impl.client.HttpClients;import org.apache.http.message.BasicNameValuePair;import org.apache.http.util.EntityUtils;import org.junit.Test; public class HttpClientTest &#123; @Test public void jUnitTest() &#123; get(); &#125; /** * HttpClient连接SSL */ public void ssl() &#123; CloseableHttpClient httpclient = null; try &#123; KeyStore trustStore = KeyStore.getInstance(KeyStore.getDefaultType()); FileInputStream instream = new FileInputStream(new File(\"d:\\\\tomcat.keystore\")); try &#123; // 加载keyStore d:\\\\tomcat.keystore trustStore.load(instream, \"123456\".toCharArray()); &#125; catch (CertificateException e) &#123; e.printStackTrace(); &#125; finally &#123; try &#123; instream.close(); &#125; catch (Exception ignore) &#123; &#125; &#125; // 相信自己的CA和所有自签名的证书 SSLContext sslcontext = SSLContexts.custom().loadTrustMaterial(trustStore, new TrustSelfSignedStrategy()).build(); // 只允许使用TLSv1协议 SSLConnectionSocketFactory sslsf = new SSLConnectionSocketFactory(sslcontext, new String[] &#123; \"TLSv1\" &#125;, null, SSLConnectionSocketFactory.BROWSER_COMPATIBLE_HOSTNAME_VERIFIER); httpclient = HttpClients.custom().setSSLSocketFactory(sslsf).build(); // 创建http请求(get方式) HttpGet httpget = new HttpGet(\"https://localhost:8443/myDemo/Ajax/serivceJ.action\"); System.out.println(\"executing request\" + httpget.getRequestLine()); CloseableHttpResponse response = httpclient.execute(httpget); try &#123; HttpEntity entity = response.getEntity(); System.out.println(\"----------------------------------------\"); System.out.println(response.getStatusLine()); if (entity != null) &#123; System.out.println(\"Response content length: \" + entity.getContentLength()); System.out.println(EntityUtils.toString(entity)); EntityUtils.consume(entity); &#125; &#125; finally &#123; response.close(); &#125; &#125; catch (ParseException e) &#123; e.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; catch (KeyManagementException e) &#123; e.printStackTrace(); &#125; catch (NoSuchAlgorithmException e) &#123; e.printStackTrace(); &#125; catch (KeyStoreException e) &#123; e.printStackTrace(); &#125; finally &#123; if (httpclient != null) &#123; try &#123; httpclient.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125; /** * post方式提交表单（模拟用户登录请求） */ public void postForm() &#123; // 创建默认的httpClient实例. CloseableHttpClient httpclient = HttpClients.createDefault(); // 创建httppost HttpPost httppost = new HttpPost(\"http://localhost:8080/myDemo/Ajax/serivceJ.action\"); // 创建参数队列 List formparams = new ArrayList(); formparams.add(new BasicNameValuePair(\"username\", \"admin\")); formparams.add(new BasicNameValuePair(\"password\", \"123456\")); UrlEncodedFormEntity uefEntity; try &#123; uefEntity = new UrlEncodedFormEntity(formparams, \"UTF-8\"); httppost.setEntity(uefEntity); System.out.println(\"executing request \" + httppost.getURI()); CloseableHttpResponse response = httpclient.execute(httppost); try &#123; HttpEntity entity = response.getEntity(); if (entity != null) &#123; System.out.println(\"--------------------------------------\"); System.out.println(\"Response content: \" + EntityUtils.toString(entity, \"UTF-8\")); System.out.println(\"--------------------------------------\"); &#125; &#125; finally &#123; response.close(); &#125; &#125; catch (ClientProtocolException e) &#123; e.printStackTrace(); &#125; catch (UnsupportedEncodingException e1) &#123; e1.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; // 关闭连接,释放资源 try &#123; httpclient.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; /** * 发送 post请求访问本地应用并根据传递参数不同返回不同结果 */ public void post() &#123; // 创建默认的httpClient实例. CloseableHttpClient httpclient = HttpClients.createDefault(); // 创建httppost HttpPost httppost = new HttpPost(\"http://localhost:8080/myDemo/Ajax/serivceJ.action\"); // 创建参数队列 List formparams = new ArrayList(); formparams.add(new BasicNameValuePair(\"type\", \"house\")); UrlEncodedFormEntity uefEntity; try &#123; uefEntity = new UrlEncodedFormEntity(formparams, \"UTF-8\"); httppost.setEntity(uefEntity); System.out.println(\"executing request \" + httppost.getURI()); CloseableHttpResponse response = httpclient.execute(httppost); try &#123; HttpEntity entity = response.getEntity(); if (entity != null) &#123; System.out.println(\"--------------------------------------\"); System.out.println(\"Response content: \" + EntityUtils.toString(entity, \"UTF-8\")); System.out.println(\"--------------------------------------\"); &#125; &#125; finally &#123; response.close(); &#125; &#125; catch (ClientProtocolException e) &#123; e.printStackTrace(); &#125; catch (UnsupportedEncodingException e1) &#123; e1.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; // 关闭连接,释放资源 try &#123; httpclient.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; /** * 发送 get请求 */ public void get() &#123; CloseableHttpClient httpclient = HttpClients.createDefault(); try &#123; // 创建httpget. HttpGet httpget = new HttpGet(\"http://www.baidu.com/\"); System.out.println(\"executing request \" + httpget.getURI()); // 执行get请求. CloseableHttpResponse response = httpclient.execute(httpget); try &#123; // 获取响应实体 HttpEntity entity = response.getEntity(); System.out.println(\"--------------------------------------\"); // 打印响应状态 System.out.println(response.getStatusLine()); if (entity != null) &#123; // 打印响应内容长度 System.out.println(\"Response content length: \" + entity.getContentLength()); // 打印响应内容 System.out.println(\"Response content: \" + EntityUtils.toString(entity)); &#125; System.out.println(\"------------------------------------\"); &#125; finally &#123; response.close(); &#125; &#125; catch (ClientProtocolException e) &#123; e.printStackTrace(); &#125; catch (ParseException e) &#123; e.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; // 关闭连接,释放资源 try &#123; httpclient.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; /** * 上传文件 */ public void upload() &#123; CloseableHttpClient httpclient = HttpClients.createDefault(); try &#123; HttpPost httppost = new HttpPost(\"http://localhost:8080/myDemo/Ajax/serivceFile.action\"); FileBody bin = new FileBody(new File(\"F:\\\\image\\\\sendpix0.jpg\")); StringBody comment = new StringBody(\"A binary file of some kind\", ContentType.TEXT_PLAIN); HttpEntity reqEntity = MultipartEntityBuilder.create().addPart(\"bin\", bin).addPart(\"comment\", comment).build(); httppost.setEntity(reqEntity); System.out.println(\"executing request \" + httppost.getRequestLine()); CloseableHttpResponse response = httpclient.execute(httppost); try &#123; System.out.println(\"----------------------------------------\"); System.out.println(response.getStatusLine()); HttpEntity resEntity = response.getEntity(); if (resEntity != null) &#123; System.out.println(\"Response content length: \" + resEntity.getContentLength()); &#125; EntityUtils.consume(resEntity); &#125; finally &#123; response.close(); &#125; &#125; catch (ClientProtocolException e) &#123; e.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; try &#123; httpclient.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125;","categories":[{"name":"技术","slug":"技术","permalink":"RmBBBBBBBBB.github.io.git/categories/技术/"}],"tags":[{"name":"HttpCilent","slug":"HttpCilent","permalink":"RmBBBBBBBBB.github.io.git/tags/HttpCilent/"},{"name":"java","slug":"java","permalink":"RmBBBBBBBBB.github.io.git/tags/java/"}]},{"title":"如何在linux上搭建hexo博客","slug":"在linux上搭建hexo博客","date":"2018-11-27T02:33:57.000Z","updated":"2018-11-27T05:56:46.105Z","comments":true,"path":"在linux上搭建hexo博客/","link":"","permalink":"RmBBBBBBBBB.github.io.git/在linux上搭建hexo博客/","excerpt":"","text":"一 环境​ 1.Linux服务器一台：阿里云购买，或者centos操作系统 ​ 2.Node.js环境 ​ 3.Nginx:用作代理，直接’yun install nginx‘即可 ​ 4.Git：链接github 同步，域名链接 二 安装Node.js12# npm config get registry // https://registry.npmjs.org/# npm config set registry https://registry.npm.taobao.org ​ 使用 node -v &amp; npm -v 命令查询是否安装成功 三 安装 Nginx yun install nginx 安装 修改nginx配置文件，vi /etc/nginx/nginx.confg 123456789101112http&#123;#省略其他配置 server &#123; listen 80; server_name localhost; #省略其他配置 location / &#123; # 将blog目录下的全路径public复制进来 root /opt/myBlog/public; &#125; &#125; &#125; 四 安装git 注册 https://github.com/ 创建项目为 yourusername.github.io （一定是[你用户名.github.io] 生成ssh key 123mkdir ~/.ssh cd ~/.sshssh-keygen -t rsa 自己用的电脑，不用设置密码啥的，一路回车就行，这时候会在 ~/.ssh/下生成两个ssh key 1ssh-add ~/.ssh/id_rsa.pub 这一步是使用刚才生成那个公钥作为本机ssh使用的口令 进入GitHub个人设置页面，点击SSH and GPGkeys 添加一个SSH key 题目自拟，复制以下输出： 1cat ~/.ssh/id_rsa.pub 以上SSH就配置好了，接下来是配置git 12git config –global user.name “xxx” git config –global user.email “xxx@xxx.com” 接下来测试一下吧 1ssh -T git@github.com 五 搭建本地hexo 安装hexo 1234567npm install hexo-cli -g cd hexo init blog cd blog npm install hexo server npm install hexo-deployer-git –save 在网站的_config.yml中配置deploy 12345deploy: type: git repo: &lt;repository url&gt; branch: [branch] # branch为分支，默认为master,可以不配置 repo为仓库地址，在github上新建仓库后，可复制此地址 测试 123hexo clean hexo g hexo s 部署到 github 1hexo d","categories":[],"tags":[]}]}