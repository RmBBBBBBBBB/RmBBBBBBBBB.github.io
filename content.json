{"meta":{"title":"一个青年的Class","subtitle":"Stay Hungry, Stay Foolish","description":"个人战，主要涉及知识共享,实践教程,前沿技术共同学习等方面","author":"杨瑞峰","url":"RmBBBBBBBBB.github.io.git"},"pages":[{"title":"about","date":"2018-11-21T03:22:53.000Z","updated":"2018-11-21T03:22:53.780Z","comments":true,"path":"about/index.html","permalink":"RmBBBBBBBBB.github.io.git/about/index.html","excerpt":"","text":""},{"title":"categories","date":"2018-11-21T03:22:47.000Z","updated":"2018-11-21T03:25:38.237Z","comments":false,"path":"categories/index.html","permalink":"RmBBBBBBBBB.github.io.git/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2018-11-21T03:22:31.000Z","updated":"2018-11-21T03:28:33.702Z","comments":false,"path":"tags/index.html","permalink":"RmBBBBBBBBB.github.io.git/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"HttpClient验证接口","slug":"HttpClient验证接口","date":"2019-02-15T08:02:25.560Z","updated":"2019-02-15T08:02:25.555Z","comments":true,"path":"HttpClient验证接口/","link":"","permalink":"RmBBBBBBBBB.github.io.git/HttpClient验证接口/","excerpt":"","text":"Http协议的重要性相信不用我多说了，HttpClient相比传统JDK自带的URLConnection，增加了易用性和灵活性（具体区别，日后我们再讨论），它不仅是客户端发送Http请求变得容易，而且也方便了开发人员测试接口（基于Http协议的），即提高了开发的效率，也方便提高代码的健壮性。因此熟练掌握HttpClient是很重要的必修内容，掌握HttpClient后，相信对于Http协议的了解会更加深入。 一、简介HttpClient是Apache Jakarta Common下的子项目，用来提供高效的、最新的、功能丰富的支持HTTP协议的客户端编程工具包，并且它支持HTTP协议最新的版本和建议。HttpClient已经应用在很多的项目中，比如Apache Jakarta上很著名的另外两个开源项目Cactus和HTMLUnit都使用了HttpClient。 下载地址: http://hc.apache.org/downloads.cgi #####二、特性 基于标准、纯净的java语言。实现了Http1.0和Http1.1 以可扩展的面向对象的结构实现了Http全部的方法（GET, POST, PUT, DELETE, HEAD, OPTIONS, and TRACE）。 支持HTTPS协议。 通过Http代理建立透明的连接。 利用CONNECT方法通过Http代理建立隧道的https连接。 Basic, Digest, NTLMv1, NTLMv2, NTLM2 Session, SNPNEGO/Kerberos认证方案。 插件式的自定义认证方案。 便携可靠的套接字工厂使它更容易的使用第三方解决方案。 连接管理器支持多线程应用。支持设置最大连接数，同时支持设置每个主机的最大连接数，发现并关闭过期的连接。 自动处理Set-Cookie中的Cookie。 插件式的自定义Cookie策略。 Request的输出流可以避免流中内容直接缓冲到socket服务器。 Response的输入流可以有效的从socket服务器直接读取相应内容。 在http1.0和http1.1中利用KeepAlive保持持久连接。 直接获取服务器发送的response code和 headers。 设置连接超时的能力。 实验性的支持http1.1 response caching。 源代码基于Apache License 可免费获取。 #####三、使用方法使用HttpClient发送请求、接收响应很简单，一般需要如下几步即可。 创建HttpClient对象。 创建请求方法的实例，并指定请求URL。如果需要发送GET请求，创建HttpGet对象；如果需要发送POST请求，创建HttpPost对象。 如果需要发送请求参数，可调用HttpGet、HttpPost共同的setParams(HetpParams params)方法来添加请求参数；对于HttpPost对象而言，也可调用setEntity(HttpEntity entity)方法来设置请求参数。 调用HttpClient对象的execute(HttpUriRequest request)发送请求，该方法返回一个HttpResponse。 调用HttpResponse的getAllHeaders()、getHeaders(String name)等方法可获取服务器的响应头；调用HttpResponse的getEntity()方法可获取HttpEntity对象，该对象包装了服务器的响应内容。程序可通过该对象获取服务器的响应内容。 释放连接。无论执行方法是否成功，都必须释放连接 第一种验证方式： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155import java.io.File;import java.io.FileInputStream;import java.io.IOException;import java.net.Socket;import java.net.UnknownHostException;import java.security.KeyManagementException;import java.security.KeyStoreException;import java.security.UnrecoverableKeyException;import java.security.KeyStore;import java.security.NoSuchAlgorithmException;import java.security.cert.CertificateException;import java.security.cert.X509Certificate;import javax.net.ssl.KeyManager;import javax.net.ssl.KeyManagerFactory;import javax.net.ssl.SSLContext;import javax.net.ssl.X509TrustManager;import javax.net.ssl.TrustManager;import org.apache.http.HttpEntity;import org.apache.http.HttpResponse;import org.apache.http.HttpVersion;import org.apache.http.client.HttpClient;import org.apache.http.client.methods.HttpPost;import org.apache.http.conn.ClientConnectionManager;import org.apache.http.conn.scheme.PlainSocketFactory;import org.apache.http.conn.scheme.Scheme;import org.apache.http.conn.scheme.SchemeRegistry;import org.apache.http.conn.socket.ConnectionSocketFactory;import org.apache.http.conn.socket.PlainConnectionSocketFactory;import org.apache.http.conn.ssl.SSLConnectionSocketFactory;import org.apache.http.conn.ssl.SSLSocketFactory;import org.apache.http.conn.ssl.TrustStrategy;import org.apache.http.conn.ssl.TrustSelfSignedStrategy;import org.apache.http.entity.StringEntity;import org.apache.http.impl.client.CloseableHttpClient;import org.apache.http.impl.client.DefaultHttpClient;import org.apache.http.impl.client.HttpClients;import org.apache.http.impl.conn.BasicClientConnectionManager;import org.apache.http.impl.conn.DefaultProxyRoutePlanner;import org.apache.http.impl.conn.PoolingHttpClientConnectionManager;import org.apache.http.message.BasicNameValuePair;import org.apache.http.params.BasicHttpParams;import org.apache.http.params.HttpParams;import org.apache.http.params.HttpProtocolParams;import org.apache.http.protocol.HTTP;import org.apache.http.util.EntityUtils;/**- @param keyStorePath 密钥库路径 @param keyStorepass 密钥库密码 - @return / public static HttpClient customSSLClient(String keyStorePath, String keyStorepass) throws Exception &#123; HttpClient httpClient; // KeyStore trustStore = KeyStore.getInstance(\"PKCS12\"); // KeyStore trustStore = KeyStore.getInstance(KeyStore.getDefaultType()); KeyStore trustStore = KeyStore.getInstance(\"JKS\"); FileInputStream instream = new FileInputStream(new File(keyStorePath)); try &#123; trustStore.load(instream, keyStorepass.toCharArray()); &#125; finally &#123; try &#123; instream.close(); &#125; catch (Exception ignore) &#123; &#125; &#125; SSLSocketFactory sf = new SSLSocketFactoryEx(trustStore, keyStorepass.toCharArray()); sf.setHostnameVerifier(SSLSocketFactory.ALLOW_ALL_HOSTNAME_VERIFIER); HttpParams params = new BasicHttpParams(); HttpProtocolParams.setVersion(params, HttpVersion.HTTP_1_1); HttpProtocolParams.setContentCharset(params, HTTP.UTF_8); SchemeRegistry registry = new SchemeRegistry(); registry.register(new Scheme(\"http\", PlainSocketFactory.getSocketFactory(), 80)); registry.register(new Scheme(\"https\", sf, 443)); ClientConnectionManager ccm = new BasicClientConnectionManager(registry); httpClient = new DefaultHttpClient(ccm); return httpClient; &#125; private static class SSLSocketFactoryEx extends SSLSocketFactory &#123; SSLContext sslContext = SSLContext.getInstance(\"TLS\"); public SSLSocketFactoryEx(KeyStore truststore, char[] arry) throws NoSuchAlgorithmException, KeyManagementException, KeyStoreException, UnrecoverableKeyException &#123; super(truststore); KeyManagerFactory localKeyManagerFactory = KeyManagerFactory.getInstance(KeyManagerFactory .getDefaultAlgorithm()); localKeyManagerFactory.init(truststore, arry); KeyManager[] arrayOfKeyManager = localKeyManagerFactory.getKeyManagers(); TrustManager tm = new X509TrustManager() &#123; @Override public X509Certificate[] getAcceptedIssuers() &#123; return null; &#125; @Override public void checkServerTrusted(X509Certificate[] chain, String authType) throws CertificateException &#123; &#125; @Override public void checkClientTrusted(X509Certificate[] chain, String authType) throws CertificateException &#123; &#125; &#125;; sslContext.init(arrayOfKeyManager, new TrustManager[]&#123;tm&#125;, new java.security.SecureRandom()); &#125; @Override public Socket createSocket(Socket socket, String host, int port, boolean autoClose) throws IOException, UnknownHostException &#123; return sslContext.getSocketFactory().createSocket(socket, host, port, autoClose); &#125; @Override public Socket createSocket() throws IOException &#123; return sslContext.getSocketFactory().createSocket(); &#125; &#125; //main方法public static void main(String[] args) throws Exception &#123; String keyStorePath =\"d:\\\\java\\\\hgclient.keystore\"; String keyStorepass =\"123456\"; HttpClient customSSLClient = customSSLClient(keyStorePath, keyStorepass); HttpPost httpPost = new HttpPost(\"https://114.116.131.5:18443/hgpayment/XmlTransServlet\"); HttpResponse execute = customSSLClient.execute(httpPost); if(execute.getStatusLine().getStatusCode()==200)&#123; HttpEntity entity = execute.getEntity();//调用getEntity()方法获取到一个HttpEntity实例 //用EntityUtils.toString()这个静态方法将HttpEntity转换成字符串,防止服务器返回的数据带有中文,所以在转换的时候将字符集指定成utf-8就可以了 String string = EntityUtils.toString(entity,\"utf-8\"); System.out.println(\"--EntityUtils--\"+string); System.out.println(\"response.getStatusLine()-----\"+execute.getStatusLine()); &#125; &#125; 第二种验证方式：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667import org.apache.commons.io.IOUtils;import org.apache.http.HttpEntity;import org.apache.http.client.methods.CloseableHttpResponse;import org.apache.http.client.methods.HttpPost;import org.apache.http.conn.ssl.SSLConnectionSocketFactory;import org.apache.http.conn.ssl.TrustStrategy;import org.apache.http.impl.client.CloseableHttpClient;import org.apache.http.impl.client.HttpClients;import org.apache.http.ssl.SSLContexts;import org.apache.http.util.EntityUtils;import javax.net.ssl.SSLContext;import java.io.File;import java.io.FileInputStream;import java.security.KeyStore;import java.security.cert.CertificateException;import java.security.cert.X509Certificate;public static void main(String[] args) throws Exception &#123; KeyStore keyStore = KeyStore.getInstance(\"PKCS12\"); keyStore.load(new FileInputStream(new File(\"D:\\\\java\\\\hgclient.keystore\")), \"123456\".toCharArray()); SSLContext sslcontext = SSLContexts.custom() //忽略掉对服务器端证书的校验 .loadTrustMaterial(new TrustStrategy() &#123; @Override public boolean isTrusted(X509Certificate[] chain, String authType) throws CertificateException &#123; return true; &#125; &#125;) //加载服务端提供的truststore(如果服务器提供truststore的话就不用忽略对服务器端证书的校验了) //.loadTrustMaterial(new File(\"D:\\\\truststore.jks\"), \"123456\".toCharArray(), // new TrustSelfSignedStrategy()) .loadKeyMaterial(keyStore, \"123456\".toCharArray()) .build(); SSLConnectionSocketFactory sslConnectionSocketFactory = new SSLConnectionSocketFactory( sslcontext, new String[]&#123;\"TLSv1\"&#125;, null, SSLConnectionSocketFactory.getDefaultHostnameVerifier()); CloseableHttpClient httpclient = HttpClients.custom() .setSSLSocketFactory(sslConnectionSocketFactory) .build(); try &#123; // HttpGet httpget = new HttpGet(\"https://114.116.131.5:18443/hgpayment/XmlTransServlet\"); // HttpPost HttpPost = new HttpPost(\"https://114.116.131.5:18443/hgpayment/XmlTransServlet\"); HttpPost HttpPost = new HttpPost(\"https://114.116.131.5:18443/hgsptsmsm/XmlSptsmServlet\"); // HttpPost HttpPost = new HttpPost(\"https://sptsm.heigo.com.cn/hgpayment/XmlTransServlet\"); System.out.println(\"Executing request \" + HttpPost.getRequestLine()); CloseableHttpResponse response = httpclient.execute(HttpPost); try &#123; HttpEntity entity = response.getEntity(); System.out.println(\"response.getStatusLine()-----\"+response.getStatusLine()); System.out.println(\"----IO----\"+IOUtils.toString(entity.getContent())); EntityUtils.consume(entity); &#125; finally &#123; response.close(); &#125; &#125; finally &#123; httpclient.close(); &#125; &#125; 第三种验证post，get，upload123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275import java.io.File;import java.io.FileInputStream;import java.io.IOException;import java.io.UnsupportedEncodingException;import java.security.KeyManagementException;import java.security.KeyStore;import java.security.KeyStoreException;import java.security.NoSuchAlgorithmException;import java.security.cert.CertificateException;import java.util.ArrayList;import java.util.List; import javax.net.ssl.SSLContext; import org.apache.http.HttpEntity;import org.apache.http.NameValuePair;import org.apache.http.ParseException;import org.apache.http.client.ClientProtocolException;import org.apache.http.client.entity.UrlEncodedFormEntity;import org.apache.http.client.methods.CloseableHttpResponse;import org.apache.http.client.methods.HttpGet;import org.apache.http.client.methods.HttpPost;import org.apache.http.conn.ssl.SSLConnectionSocketFactory;import org.apache.http.conn.ssl.SSLContexts;import org.apache.http.conn.ssl.TrustSelfSignedStrategy;import org.apache.http.entity.ContentType;import org.apache.http.entity.mime.MultipartEntityBuilder;import org.apache.http.entity.mime.content.FileBody;import org.apache.http.entity.mime.content.StringBody;import org.apache.http.impl.client.CloseableHttpClient;import org.apache.http.impl.client.HttpClients;import org.apache.http.message.BasicNameValuePair;import org.apache.http.util.EntityUtils;import org.junit.Test; public class HttpClientTest &#123; @Test public void jUnitTest() &#123; get(); &#125; /** * HttpClient连接SSL */ public void ssl() &#123; CloseableHttpClient httpclient = null; try &#123; KeyStore trustStore = KeyStore.getInstance(KeyStore.getDefaultType()); FileInputStream instream = new FileInputStream(new File(\"d:\\\\tomcat.keystore\")); try &#123; // 加载keyStore d:\\\\tomcat.keystore trustStore.load(instream, \"123456\".toCharArray()); &#125; catch (CertificateException e) &#123; e.printStackTrace(); &#125; finally &#123; try &#123; instream.close(); &#125; catch (Exception ignore) &#123; &#125; &#125; // 相信自己的CA和所有自签名的证书 SSLContext sslcontext = SSLContexts.custom().loadTrustMaterial(trustStore, new TrustSelfSignedStrategy()).build(); // 只允许使用TLSv1协议 SSLConnectionSocketFactory sslsf = new SSLConnectionSocketFactory(sslcontext, new String[] &#123; \"TLSv1\" &#125;, null, SSLConnectionSocketFactory.BROWSER_COMPATIBLE_HOSTNAME_VERIFIER); httpclient = HttpClients.custom().setSSLSocketFactory(sslsf).build(); // 创建http请求(get方式) HttpGet httpget = new HttpGet(\"https://localhost:8443/myDemo/Ajax/serivceJ.action\"); System.out.println(\"executing request\" + httpget.getRequestLine()); CloseableHttpResponse response = httpclient.execute(httpget); try &#123; HttpEntity entity = response.getEntity(); System.out.println(\"----------------------------------------\"); System.out.println(response.getStatusLine()); if (entity != null) &#123; System.out.println(\"Response content length: \" + entity.getContentLength()); System.out.println(EntityUtils.toString(entity)); EntityUtils.consume(entity); &#125; &#125; finally &#123; response.close(); &#125; &#125; catch (ParseException e) &#123; e.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; catch (KeyManagementException e) &#123; e.printStackTrace(); &#125; catch (NoSuchAlgorithmException e) &#123; e.printStackTrace(); &#125; catch (KeyStoreException e) &#123; e.printStackTrace(); &#125; finally &#123; if (httpclient != null) &#123; try &#123; httpclient.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125; /** * post方式提交表单（模拟用户登录请求） */ public void postForm() &#123; // 创建默认的httpClient实例. CloseableHttpClient httpclient = HttpClients.createDefault(); // 创建httppost HttpPost httppost = new HttpPost(\"http://localhost:8080/myDemo/Ajax/serivceJ.action\"); // 创建参数队列 List formparams = new ArrayList(); formparams.add(new BasicNameValuePair(\"username\", \"admin\")); formparams.add(new BasicNameValuePair(\"password\", \"123456\")); UrlEncodedFormEntity uefEntity; try &#123; uefEntity = new UrlEncodedFormEntity(formparams, \"UTF-8\"); httppost.setEntity(uefEntity); System.out.println(\"executing request \" + httppost.getURI()); CloseableHttpResponse response = httpclient.execute(httppost); try &#123; HttpEntity entity = response.getEntity(); if (entity != null) &#123; System.out.println(\"--------------------------------------\"); System.out.println(\"Response content: \" + EntityUtils.toString(entity, \"UTF-8\")); System.out.println(\"--------------------------------------\"); &#125; &#125; finally &#123; response.close(); &#125; &#125; catch (ClientProtocolException e) &#123; e.printStackTrace(); &#125; catch (UnsupportedEncodingException e1) &#123; e1.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; // 关闭连接,释放资源 try &#123; httpclient.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; /** * 发送 post请求访问本地应用并根据传递参数不同返回不同结果 */ public void post() &#123; // 创建默认的httpClient实例. CloseableHttpClient httpclient = HttpClients.createDefault(); // 创建httppost HttpPost httppost = new HttpPost(\"http://localhost:8080/myDemo/Ajax/serivceJ.action\"); // 创建参数队列 List formparams = new ArrayList(); formparams.add(new BasicNameValuePair(\"type\", \"house\")); UrlEncodedFormEntity uefEntity; try &#123; uefEntity = new UrlEncodedFormEntity(formparams, \"UTF-8\"); httppost.setEntity(uefEntity); System.out.println(\"executing request \" + httppost.getURI()); CloseableHttpResponse response = httpclient.execute(httppost); try &#123; HttpEntity entity = response.getEntity(); if (entity != null) &#123; System.out.println(\"--------------------------------------\"); System.out.println(\"Response content: \" + EntityUtils.toString(entity, \"UTF-8\")); System.out.println(\"--------------------------------------\"); &#125; &#125; finally &#123; response.close(); &#125; &#125; catch (ClientProtocolException e) &#123; e.printStackTrace(); &#125; catch (UnsupportedEncodingException e1) &#123; e1.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; // 关闭连接,释放资源 try &#123; httpclient.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; /** * 发送 get请求 */ public void get() &#123; CloseableHttpClient httpclient = HttpClients.createDefault(); try &#123; // 创建httpget. HttpGet httpget = new HttpGet(\"http://www.baidu.com/\"); System.out.println(\"executing request \" + httpget.getURI()); // 执行get请求. CloseableHttpResponse response = httpclient.execute(httpget); try &#123; // 获取响应实体 HttpEntity entity = response.getEntity(); System.out.println(\"--------------------------------------\"); // 打印响应状态 System.out.println(response.getStatusLine()); if (entity != null) &#123; // 打印响应内容长度 System.out.println(\"Response content length: \" + entity.getContentLength()); // 打印响应内容 System.out.println(\"Response content: \" + EntityUtils.toString(entity)); &#125; System.out.println(\"------------------------------------\"); &#125; finally &#123; response.close(); &#125; &#125; catch (ClientProtocolException e) &#123; e.printStackTrace(); &#125; catch (ParseException e) &#123; e.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; // 关闭连接,释放资源 try &#123; httpclient.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; /** * 上传文件 */ public void upload() &#123; CloseableHttpClient httpclient = HttpClients.createDefault(); try &#123; HttpPost httppost = new HttpPost(\"http://localhost:8080/myDemo/Ajax/serivceFile.action\"); FileBody bin = new FileBody(new File(\"F:\\\\image\\\\sendpix0.jpg\")); StringBody comment = new StringBody(\"A binary file of some kind\", ContentType.TEXT_PLAIN); HttpEntity reqEntity = MultipartEntityBuilder.create().addPart(\"bin\", bin).addPart(\"comment\", comment).build(); httppost.setEntity(reqEntity); System.out.println(\"executing request \" + httppost.getRequestLine()); CloseableHttpResponse response = httpclient.execute(httppost); try &#123; System.out.println(\"----------------------------------------\"); System.out.println(response.getStatusLine()); HttpEntity resEntity = response.getEntity(); if (resEntity != null) &#123; System.out.println(\"Response content length: \" + resEntity.getContentLength()); &#125; EntityUtils.consume(resEntity); &#125; finally &#123; response.close(); &#125; &#125; catch (ClientProtocolException e) &#123; e.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; try &#123; httpclient.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125;","categories":[],"tags":[]},{"title":"如何在linux上搭建hexo博客","slug":"在linux上搭建hexo博客","date":"2018-11-27T02:33:57.000Z","updated":"2018-11-27T05:56:46.105Z","comments":true,"path":"在linux上搭建hexo博客/","link":"","permalink":"RmBBBBBBBBB.github.io.git/在linux上搭建hexo博客/","excerpt":"","text":"一 环境​ 1.Linux服务器一台：阿里云购买，或者centos操作系统 ​ 2.Node.js环境 ​ 3.Nginx:用作代理，直接’yun install nginx‘即可 ​ 4.Git：链接github 同步，域名链接 二 安装Node.js12# npm config get registry // https://registry.npmjs.org/# npm config set registry https://registry.npm.taobao.org ​ 使用 node -v &amp; npm -v 命令查询是否安装成功 三 安装 Nginx yun install nginx 安装 修改nginx配置文件，vi /etc/nginx/nginx.confg 123456789101112http&#123;#省略其他配置 server &#123; listen 80; server_name localhost; #省略其他配置 location / &#123; # 将blog目录下的全路径public复制进来 root /opt/myBlog/public; &#125; &#125; &#125; 四 安装git 注册 https://github.com/ 创建项目为 yourusername.github.io （一定是[你用户名.github.io] 生成ssh key 123mkdir ~/.ssh cd ~/.sshssh-keygen -t rsa 自己用的电脑，不用设置密码啥的，一路回车就行，这时候会在 ~/.ssh/下生成两个ssh key 1ssh-add ~/.ssh/id_rsa.pub 这一步是使用刚才生成那个公钥作为本机ssh使用的口令 进入GitHub个人设置页面，点击SSH and GPGkeys 添加一个SSH key 题目自拟，复制以下输出： 1cat ~/.ssh/id_rsa.pub 以上SSH就配置好了，接下来是配置git 12git config –global user.name “xxx” git config –global user.email “xxx@xxx.com” 接下来测试一下吧 1ssh -T git@github.com 五 搭建本地hexo 安装hexo 1234567npm install hexo-cli -g cd hexo init blog cd blog npm install hexo server npm install hexo-deployer-git –save 在网站的_config.yml中配置deploy 12345deploy: type: git repo: &lt;repository url&gt; branch: [branch] # branch为分支，默认为master,可以不配置 repo为仓库地址，在github上新建仓库后，可复制此地址 测试 123hexo clean hexo g hexo s 部署到 github 1hexo d","categories":[],"tags":[]}]}